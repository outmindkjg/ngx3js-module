<!DOCTYPE html>
<html lang="en">
	<head>
<meta charset="utf-8" />
<base href="../../../" />
<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
	 * [Texture](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Texture) &rarr;
<h1>[name]</h1>
	 * Creates a texture directly from raw data, width and height.
<h2>Constructor</h2>
<h3>[name]( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding )</h3>
	 * The data argument must be an [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView).
	 * Further parameters correspond to the properties inherited from [Texture](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Texture), where both magFilter and minFilter default to THREE.NearestFilter. The properties flipY and generateMipmaps are initially set to false.
	 * The interpretation of the data depends on type and format:
	 * If the type is THREE.UnsignedByteType, a Uint8Array will be useful for addressing the texel data.
	 * If the format is THREE.RGBAFormat, data needs four values for one texel; Red, Green, Blue and Alpha (typically the opacity). Similarly, THREE.RGBFormat specifies a format where only three values are used for each texel.
	 * For the packed types, THREE.UnsignedShort4444Type, THREE.UnsignedShort5551Type or THREE.UnsignedShort565Type, all color components of one texel can be addressed as bitfields within an integer element of a Uint16Array.
	 * In order to use the types THREE.FloatType and THREE.HalfFloatType, the WebGL implementation must support the respective extensions OES_texture_float and OES_texture_half_float. In order to use THREE.LinearFilter for component-wise, bilinear interpolation of the texels based on these types, the WebGL extensions OES_texture_float_linear or OES_texture_half_float_linear must also be present.
	 * ### Code Example
	 * ```javascript
	 * // create a buffer with color data
	 * const width = 512;
	 * const height = 512;
	 * const size = width * height;
	 * const data = new Uint8Array( 3 * size );
	 * const color = new THREE.Color( 0xffffff );
	 * const r = Math.floor( color.r * 255 );
	 * const g = Math.floor( color.g * 255 );
	 * const b = Math.floor( color.b * 255 );
	 * for ( let i = 0; i < size; i ++ ) {
	 * const stride = i * 3;
	 * data[ stride ] = r;
	 * data[ stride + 1 ] = g;
	 * data[ stride + 2 ] = b;
	 * }
	 * // used the buffer to create a [name]
	 * const texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
	 * texture.needsUpdate = true;
<h2>Properties</h2>
	 * See the base [Texture](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Texture) class for common properties.
<h3>[property:Image image]</h3>
	 * Overridden with a record type holding data, width and height.
<h2>Methods</h2>
	 * See the base [Texture](https://outmindkjg.github.io/ngx3js-doc/#/docs/ngxapi/en/Texture) class for common methods.
<h2>Source</h2>
	 * [src/[path](https://github.com/mrdoob/three.js/blob/master/src/[path].js).js]
	</body>
</html>
